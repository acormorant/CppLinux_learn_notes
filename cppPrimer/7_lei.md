
    Sales_data类
    练习
    7.2/7.6/封装/7.11构造函数/7.21友元/7.26
    7.41 委托构造函数重写Sales_data
    7.7 交易处理系统

    Person类
    练习
    7.4/7.5/7.9read print/7.15构造函数/7.19封装/7.22/7.50explicit

    Screen类 /Window_mgr类
    练习
    7.23/7.24/7.25/7.27/7.29/7.32/7.33

    Debug类
    练习7.53/7.54
    Account类
    练习7.57


# 类
**类的基本思想是数据抽象和封装。**

**抽象是一种依赖于接口和实现分离的编程技术。**

**封装实现了类的接口和实现的分离。**

## 7.1 定义抽象数据类型
1.this任何对类成员的直接访问都被看作this的隐式引用。
 `std::string isbn() const {return bookNo;}`
 等价于
 `std::string isbn() const {return this->bookNo;}`

2.在类的外部定义成员函数类外部定义的成员的名字必须包含它所属的类名。
```cpp
 double Sales_data::avg_price() const {
	if (units_sol)
		return revenue/units_sols;
	else
		return 0;
}
```
3.构造函数
 >定义: 类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。

 - 构造函数没有返回类型；构造函数的名字和类名相同。
 - 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数。
 - 编译器创建的构造函数被称为合成的默认构造函数。
 - **只有当类没有声明任何构造函数的时，编译器才会自动的生成默认构造函数。
  一旦我们定义了一些其他的构造函数，除非我们再定义一个默认的构造函数，否则类将没有默认构造函数**



## 7.2 访问控制与封装
1.访问控制
 **public:**  使用public定义的成员，在整个程序内可被访问，public成员定义类的接口。 
 **private:** 使用private定义的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。 

2.友元
 友元类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。
 以friend关键字标识。友元不是类的成员，不受访问控制级别的约束。
 **友元的声明仅仅制定了访问的权限，而非通常意义的函数声明。
 必须在友元之外再专门对函数进行一次声明。**

---
## 



