# 2、信息的表示和处理
- 浮点数表示的精度有限，因而浮点运算是不可结合的。
- 整数的表示范围小但是精确，浮点数表示的范围大但是是近似的。
## 2.1 信息存储
- 计算机一般使用字节作为最小的可寻址的内存单位。
- 指针的值是某个存储块的第一个字节的虚拟地址。
- 每个程序对象可以视为一个字节块。
### 2.1.2 字数据大小
- 每个计算机有对应的字长，虚拟地址用一个字来编码，所以字长决定了虚拟地址空间的大小。64 位机器的指针类型长度为 8 字节.32位机器的虚拟地址空间为 4GB，64 位字长的虚拟地址空间位 16 EB。
- 为了避免依赖典型数据类型大小与不同编译器设置带来的错误，引入int32_t,int64_t等固定大小数据类型，其不随编译器和机器设置变化。**使用确定大小的整数类型是程序员准确控制数据表示的最佳途径；**
### 2.1.3 寻址和字节顺序
对于跨越多字节的对象，它的地址是它所用字节中的最小地址。
- 两种字节存储法：
  - 小端法：数字的低位在前（前就是最小地址）
  - 大端法：数字的高位在前
- 在应用开发过程中三种可能因字节存储造成问题的场景（大多数场景其机器使用的字节顺序是完全不可见的）
  1. 不同字节存储方式的机器传递消息可能反序；解决方法为发送与接受按网络标准转换；
  2. 阅读表示整数数据的字节序列时；例如反汇编代码指令的字节级表示；
  3. 打印各类型指针地址时；对于不同的机器可能字节顺序不同；
### 2.1.4 表示字符串
C 语言字符串是以 null 字符结尾的字符数组，即 '\0'
在使用ASCII作为字符码的任何系统，在对打印字符串指针内容时都将得到相同结果，与字节顺序和字大小规则无关；
#### 字符编码相关
- [字符编码那点事：快速理解ASCII、Unicode、GBK和UTF-8](https://zhuanlan.zhihu.com/p/38333902)
  - UTF-8是Unicode的实现方式之一；其最大的特点：是一种变长的编码方式，它可以使用1-4个字节表示一个符号，根据不同的符号而变化字节长度。
    - 编码规则为：
        1. 对于单字节的符号：字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；
        2. 对于n字节的符号（n > 1）：第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
  - GB2312规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字；
    - 并把ASCII原有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。
  - Unicode、GBK和Big5码等字符集是不兼容的，同一个汉字在这三个字符集里的码值是完全不一样的。即GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换。
### 2.1.7 C语言中的位级运算（布尔运算）
void inplace_swap(int* x, int* y)   {   *y = *x ^ *y; *x = *x ^ *y; *y = *x ^ *y;  }
  - 对于运算^，每个元素的加法逆元是它本身；
### 2.1.8 C 语言中的逻辑运算
逻辑运算符 && 和 || 如果第一个参数就能确定结果，就不再计算第二个参数；
### 2.1.9 C 语言中的移位运算
左移 k 位丢掉最高的 k 位，并在右端补 k 个 0。
右移分为逻辑右移和算术右移。逻辑右移左端补 0，算术右移左端补最高有效位的值。
一般都对有符号数使用算术右移，即补符号位的值。无符号数，只能是逻辑右移，即补 0
  - C/C++中，对于无符号数，可以认为是逻辑左移和逻辑右移。对于有符号数，可以认为是算术左移和算术右移；
  -  要对一个有符号数 执行逻辑右移，可以先将它强制类型转换为无符号类型。 
  -  要对一个无符号数 执行算术右移，可以先将它强制类型转换为有符号类型。
## 2.2 整数表示
### 2.2.3 补码编码
![two's-complement](./resource/twos_Complement.avif)
- [计组与CSAPP中补码的定义](https://zhuanlan.zhihu.com/p/563722806)
  - 计组课程中的定义着重与从原码到补码的推导关系，即符号位不变, 其它位取反加1.
### 2.2.4 有符号数和无符号数之间的转换
- 在有符号数与无符号数之间进行强制类型转换的结果是保持位值不变，只改变解释位的方式。
- 补码 x 转无符号数
        x >= 0，值不变
        x < 0，转换后的值为 2^w + x
- 无符号数 x 转补码
        x < 2^(w-1)，值不变
        x >= 2^(w-1)，转换后的值为 x - 2^w
### 2.2.5 C 语言中的有符号数和无符号数
C 语言中执行运算时若双目运算符两端是有符号数与无符号数，那么将隐式强制类型转换有符号为无符号数，并假设都为非负。
### 2.2.6 扩展一个数字的位表示
扩展无符号数使用零扩展，即在最高位前加 0
扩展有符号数使用符号扩展，即在最高位前加最高有效位的值
### 2.2.7 截断数字
对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位。
对于无符号数而言，截断后的数字实际上等于 w mod 2^k，即取余。

## 2.3 整数运算
### 2.3.1 无符号加法
当 x+y >= 2^w，实际结果为 s = x+y-2^w
对任意的 x+y，s = (x+y) % 2^w
溢出的结果：和小于两个加数
**检验溢出**的方式： s < x
无符号数的非：~x = 2^w - x (x>0)
### 2.3.2 补码加法
正溢出：当 x+y >= 2^(w-1)， s = x+y-2^w
负溢出：当 x+y < -2^(w-1)，s = x+y+2^w
正溢出的结果是负数，负溢出的结果是正数。
检验x+y溢出的方式tadd_ok(x, y)：当 x,y>0 而 s<=0 是正溢出；当 x,y<0 而 s>=0 是负溢出
检验x-y溢出的方式不能单纯使用tadd_ok(x, -y), 因为补码负数和正数表示的区间不一样:  return (x >= y)?(sub >= 0):(sub < 0);
### 2.3.3 补码的非
当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x
补码非的位级表示：对每一位求补，结果再加 1
计算补码非的第二种方法：假设 k 是最右边的 1 的位置，对 k 左边的所有位取反
### 2.3.4 无符号乘法
无符号乘法的积 m = (x*y) % 2^w
### 2.3.5 补码乘法
可以认为补码乘法和无符号乘法的位级表示是一样的
C语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释
补码乘法的积 m = (x*y) % 2^w