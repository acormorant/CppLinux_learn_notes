# 网络基础部分
## tcp 三次握手/数据通信/四次挥手
![tcp](image/tcp_communication.png)
### 三次握手
- 第一次握手：客户端请求建立连接，向服务端发送一个同步报文（SYN=1），同时选择一个随机数 seq = x 作为初始序列号，并进入SYN_SENT状态，等待服务器确认。
- 第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为初始序列号，此时服务器进入SYN_RECV状态。
- 第三次握手：客户端收到服务端的确认后，向服务端发送一个确认报文（ACK=1），确认号为 ack = y + 1，序列号为 seq = x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。
#### 为什么需要三次握手，而不是两次？
1. 防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。
2. 三次握手才能让双方均确认自己和对方的发送和接收能力都正常。
    - 第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；
    - 第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；
    - 第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；
3. 告知对方自己的初始序号值，并确认收到对方的初始序号值。

### 数据通信
![data](image/data_communication.png)
#### 详细讲一下TCP的滑动窗口？
在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。
- 为了避免这种情况，TCP引入了窗口概念。**窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值**。
![](image/Sliding_window.jpg)
#### 详细讲一下拥塞控制？
- 发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwnd == ssthresh时，改用拥塞避免算法。
- TCP 一共使用了四种算法来实现拥塞控制：
    - 慢开始 (slow-start): 不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。
    - 拥塞避免 (congestion avoidance): 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。
    - 快速重传 (fast retransmit): 我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在**收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认**。
        **快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。**
        ![Fast retransmission](image/Fast_retransmission.jpg)
    - 快速恢复 (fast recovery): 主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。
    - ![Congestion avoidance](image/Congestion_avoidance.jpg)

### 四次挥手
- 第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。
    - 序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1
    - 确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1

- 第二次挥手：服务端收到连接释放报文后，立即发出确认报文（ACK=1），序列号 seq = k，确认号 ack = u + 1。
    这时 TCP 连接处于**半关闭状态**，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。

- 第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认。
    - 序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。
    - 确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据

- 第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文（ACK=1），序列号 seq = u + 1，确认号为 ack = w + 1。
    此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。而服务端只要收到客户端发出的确认，就立即进入 CLOSED 状态。

#### 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？(MSL: 最长报文段寿命)
1. 确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。
2. 防止已失效的连接请求报文段出现在之后的连接中。

#### 缓冲区
![Cache](image/Cache_area.png)
- **每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。**
  - write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。
  - read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。
##### 半关闭
 二次挥手后tcp连接半关闭状态,实质是关闭了socket的写缓冲区;

### 通信时序与代码对应关系
![](image/tcp_timing.png)


# 网络编程
## 错误处理函数封装 
- 封装目的：在 server.c 编程过程中突出逻辑，将出错处理与逻辑分开，可以直接跳转man手册。
    - 【wrap.c】存放网络通信相关常用自定义函数。命名方式：系统调用函数首字符大写,方便查看man手册如：Listen()、Accept();函数功能：调用系统调用函数，处理出错场景。
        在 server.c 和 client.c 中调用自定义函数联合编译 server.c 和 wrap.c 生成 serverclient.c; client.c 和 wrap.c 生成 client;
    - 【wrap.h】存放网络通信相关常用自定义函数原型(声明)。
## 





